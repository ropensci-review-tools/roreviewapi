#' Count number of 'srr' statistical standards complied with, and confirm
#' whether than represents > 50% of all applicable standards.
#'
#' @param repourl The URL for the repo being checked, potentially including full
#' path to non-default branch.
#' @param repo The 'context.repo' parameter defining the repository from which
#' the command was invoked, passed in 'org/repo' format.
#' @param issue_id The id (number) of the issue from which the command was
#' invoked.
#' @param post_to_issue Integer value > 0 will post results back to issue (via
#' 'gh' cli); otherwise just return character string with result.
#' @return Vector of three numbers:
#' \enumerate{
#' \item Number of standards complied with
#' \item Total number of applicable standards
#' \item Number complied with as proportion of total
#' }
#' @family ropensci
#' @export
srr_counts <- function (repourl, repo, issue_id, post_to_issue = TRUE) {

    # Content taken directly from editor_check():
    branch <- roreviewapi::get_branch_from_url (repourl)
    if (!is.null (branch)) {
        repourl <- gsub (paste0 ("\\/tree\\/", branch, ".*$"), "", repourl)
    }

    path <- roreviewapi::dl_gh_repo (u = repourl, branch = branch)

    # Then the 'srr' bit:
    if (is.null (branch)) {
        branch <- "" # for srr_report fn
    }
    srr_rep <- srr::srr_report (
        path = path, branch = branch, view = FALSE, roxygenise = FALSE
    )
    if (length (srr_rep) == 1L) { # "This is not an 'srr' package"
        out <- "This is not an 'srr' package"
        if (post_to_issue) {
            out <- roreviewapi::post_to_issue (out, repo, issue_id)
        }
        return (out)
    }

    out <- roreviewapi::srr_counts_from_report (srr_rep)

    if (post_to_issue) {

        out <- roreviewapi::post_to_issue (out, repo, issue_id)
    }

    return (out)
}

#' Extract final counts of 'srr' standards from the report
#'
#' @param srr_rep An 'srr' report generated by the `srr::srr_report()` function.
#' @return Character vector with markdown-formatted summary summary of numbers
#' of standards complied with.
#' @family ropensci
#' @export
srr_counts_from_report <- function (srr_rep) {

    index <- grep ("heavy_multiplication_x\\:\\s+Error\\:", srr_rep)
    errors <- NULL
    if (length (index) > 0L) {
        errors <- c (srr_rep [index], "")
    }

    index <- grep ("^\\#\\#\\sMissing Standards", srr_rep)

    if (length (index) > 0L) {

        missing_stds <- srr_rep [-seq (index)]
        while (!nzchar (missing_stds [1])) {
            missing_stds <- missing_stds [-1]
        }
        next_sec <- grep ("^\\#+", missing_stds)
        missing_stds <-
            missing_stds [-seq (next_sec [1], length (missing_stds))]
        while (!nzchar (missing_stds [length (missing_stds)])) {
            missing_stds <- missing_stds [-length (missing_stds)]
        }

        out <- c (
            missing_stds,
            "",
            "All standards must be documented prior to submission"
        )

        todo <- grep ("srrstatsTODO", srr_rep)
        if (length (todo) > 0L) {
            srr_rep_todo <- srr_rep [seq (todo, length (srr_rep))]
            ptn <- "^\\-\\sTotal\\s\\:"
            srr_rep_todo_total <-
                gsub (ptn, "", grep (ptn, srr_rep_todo, value = TRUE))
            srr_rep_todo_total <-
                as.integer (gsub ("^\\s|\\/.*$", "", srr_rep_todo_total))
            if (srr_rep_todo_total > 0L) {
                out <- c (
                    out, "",
                    paste0 (
                        "There are also ",
                        srr_rep_todo_total,
                        " standards with 'srrstatsTODO' tags."
                    )
                )
            }
        }

    } else {

        out <- roreviewapi::srr_counts_summary (srr_rep, has_errors = !is.null (errors))
    }

    out <- paste0 (c (errors, out), collapse = "\n")

    return (out)
}

#' Summarise counts of 'srr' standards from full 'srr' report
#'
#' @param srr_rep An 'srr' report generated by the `srr::srr_report()` function.
#' @return Character vector with markdown-formatted summary summary of numbers
#' of standards complied with.
#' @param has_errors This is `TRUE` when the 'srr' report has errors, in which
#' case the final message issued here excludes statements about package being
#' able to be submitted.
#' @family ropensci
#' @export
srr_counts_summary <- function (srr_rep, has_errors = FALSE) {

    stds_start <- grep ("^\\#\\#\\sStandards with", srr_rep)
    sections <- grep ("^\\#+", srr_rep)
    stds_end <- vapply (
        stds_start, function (i) {
            sections [which (sections > i)] [1]
        },
        integer (1L)
    )

    # as.list -> unlist to avoid accidental matrix results when numbers are
    # equal
    stds <- apply (cbind (stds_start, stds_end), 1, function (i) {
        as.list (srr_rep [seq (i [1], i [2])])
    })
    stds <- lapply (stds, unlist)

    stds_what <- vapply (
        stds, function (i) {
            gsub ("\\`", "", regmatches (i, regexpr ("\\`.*\\`", i)))
        },
        character (1L)
    )
    stds_n <- lapply (stds, function (i) {
        vals <- regmatches (i, gregexpr ("[0-9]+\\s+\\/\\s+[0-9]+$", i))
        index <- which (vapply (vals, length, integer (1L)) > 0L)
        vals <- lapply (vals [index], function (j) {
            as.integer (strsplit (j, "\\/") [[1]])
        })
        categories <-
            regmatches (i, gregexpr ("^\\-\\s+[A-Za-z]+\\s\\:", i))
        categories <- gsub ("^\\-\\s+|\\s+\\:$", "", unlist (categories))
        names (vals) <- categories
        return (vals)
    })
    names (stds_n) <- stds_what

    categories <- srr::srr_stats_categories ()

    summarise_one <- function (s, complied = TRUE) {

        stds_summary <- paste0 (
            ifelse (complied,
                "- Complied with: ",
                "- Not complied with: "
            ),
            s$Total [1],
            " / ",
            s$Total [2],
            " = ",
            round (100 * s$Total [1] / s$Total [2], digits = 1),
            "% ("
        )
        these_categories <- names (s)
        these_categories <-
            these_categories [which (!these_categories == "Total")]
        for (cat in these_categories) {
            stds_summary <- paste0 (
                stds_summary,
                categories$category [categories$std_prefix == cat],
                ": ",
                s [[cat]] [1],
                " / ",
                s [[cat]] [2],
                "; "
            )
        }
        return (gsub (";\\s$", ")", stds_summary))
    }

    stds_summary <- summarise_one (stds_n$srrstats, TRUE)
    if (!is.null (stds_n$srrstatsNA)) {
        stds_summary <- c (
            stds_summary,
            summarise_one (stds_n$srrstatsNA, FALSE)
        )
    }

    compliance <- stds_n$srrstats$Total [1] / stds_n$srrstats$Total [2]

    stds_final <- ifelse (
        compliance > 0.5,
        paste0 (
            ":heavy_check_mark: This package complies with ",
            "> 50% of all standards",
            ifelse (has_errors, "", " and may be submitted"),
            "."
        ),
        paste0 (
            ":heavy_multiplication_x: This package complies with ",
            "< 50% of all standards",
            ifelse (has_errors, "", "and is not ready to be submitted"),
            "."
        )
    )

    out <- c (
        "## 'srr' standards compliance:",
        "",
        stds_summary,
        "",
        stds_final
    )

    return (out)
}

#' Get stats badge grade and standards version for a submission
#'
#' @param repo The submission repo
#' @param issue_num GitHub issue number of submission
#' @return A single character containing the label used directly for the issue
#' badge
#' @family ropensci
#' @export
stats_badge <- function (repo = "ropensci/software-review",
                         issue_num = 258) {

    # This by default returns only the opening comment. Additional comments can
    # be extracted with the "-c" flag.
    args <- list (
        "issue",
        "view",
        issue_num,
        "-R",
        repo
    )

    out <- system2 ("gh", args = args, stdout = TRUE, wait = TRUE)

    return (stats_badge_from_opening_comment (out))
}

stats_badge_from_opening_comment <- function (out) {

    type <- get_html_var (out, "submission-type")
    if (length (type) == 0L) {
        return (NULL)
    }
    if (type != "Stats") {
        return (NULL)
    }

    labels <- grep ("^labels\\:", out, value = TRUE) [1]
    res <- NULL

    if (grepl ("approved", labels)) {

        g <- regexpr (
            "6\\/approved\\-(bronze|silver|gold)\\-v[0-9]+\\.[0-9]+$",
            labels
        )
        res <- regmatches (labels, g)

    } else {

        grade <- get_html_var (out, "statsgrade")
        if (length (grade) > 0L) {
            version <- stats_version (truncated = TRUE)
            res <- paste0 ("6/approved-", grade, "-v", version)
        }

    }

    return (res)
}

get_html_var <- function (x, expr = "submission-type") {

    x <- grep (paste0 ("<!--", expr, "-->"), x, value = TRUE)
    x <- regmatches (x, regexpr ("\\-\\->.*<!\\-\\-", x))
    x <- gsub ("\\-\\->|<!\\-\\-", "", x)

    return (x)
}

#' Get current version of statistical standards
#'
#' @return A single character containing version number
#' @noRd
stats_version <- function (truncated = TRUE) {

    u <- paste0 (
        "https://raw.githubusercontent.com/",
        "ropensci/statistical-software-review-book/",
        "main/DESCRIPTION"
    )

    tmp <- fs::path (fs::path_temp (), "stats-devguide-DESCRIPTION")
    if (!fs::file_exists (tmp)) {
        ret <- utils::download.file (u, destfile = tmp, quiet = TRUE) # nolint
    }

    d <- data.frame (read.dcf (tmp))

    version <- d$Version
    if (truncated) {
        version <- regmatches (version, regexpr ("[0-9]+\\.[0-9]+", version))
    }

    return (version)
}
